import random
import string

target = 'To be or not to be'
pool = []
size = 500
mutation_rate = 0.1

def fitness(x):
    score = 0
    for i in range(len(target)):
        score += target[i] == x[i]
    return score

def prob(lst):
    result = []
    sum = 0
    for item in lst:
        sum += item[1]
    for j in range(len(lst)):
        for i in range(lst[j][1]):
            result.append(j)
    return result

def new_gen(pool, pro):
    if pro == []:
        pool = []
        for i in range(size):
            temp = ''.join([random.choice(string.ascii_letters + string.digits+ '') for n in range(len(target))])
            pool.append([temp, fitness(temp)])
    pro = prob(pool)
    new_pool = []
    for i in range(size):
        chanse = random.uniform(0, 1)
        a = random.randint(0, len(pro)-1)
        b = random.randint(0, len(pro)-1)
        mom = pool[pro[a]][0]
        dad = pool[pro[b]][0]
        temp = ''.join([mom[:len(target)//2], dad[len(target)//2:]])
        if chanse < mutation_rate:
            ind = int(random.uniform(0, 1) * len(target) // 1)
            temp = temp[0:ind] + random.choice(string.ascii_letters+' ') + temp[ind+1:]
        new_pool.append([temp, fitness(temp)])
    return new_pool

def finished(x):
    result = False
    i = 0
    while not result and i < len(x):
        result = (x[i][0] == target or result)
        i += 1
    return result

def best(x):
    index = 0
    fit = 0
    for i in range(len(x)):
        if x[i][1] > fit:
            index = i
            fit = x[i][1]
    return [x[index][0], x[index][1]]

for i in range(size):
    temp = ''.join([random.choice(string.ascii_letters + string.digits+' ') for n in range(len(target))])
    pool.append([temp, fitness(temp)])

num_gen = 0
while not finished(pool):
    num_gen += 1
    pro = prob(pool)
    print(best(pool))
    new_pool = new_gen(pool, pro)
    pool = new_pool
print(best(pool), num_gen)
